# Задание по программированию «AirportCounter»

Условие

Вам необходимо разработать простейшую систему сбора статистики вылетов для небольших авиакомпаний. Высокоуровнево требования выглядят следующим образом:

- Система сбора статистики должна представлять собой класс AirportCounter, умеющий в произвольный момент времени для заданного аэропорта вернуть текущее количество вылетов из него.
- Набор возможных аэропортов фиксирован в виде enum и потому не может изменяться в рамках одного сеанса работы системы статистики, то есть в рамках одного экземпляра AirportCounter. Таким образом, класс AirportCounter необходимо шаблонизировать типом этого enum: если назвать такой enum TAirport, получим шаблонный класс AirportCounter<TAirport>
- Гарантируется (по крайней мере, обещано заказчиком), что по enum аэропортов можно будет легко определить количество элементов в нём, а также перебрать сами элементы. А именно, любой используемый enum будет иметь вид enum class SomeCityAirport { Airport1, Airport2, ..., AirportN, Last* };, то есть будет содержать некоторое количество элементов-аэропортов и элемент Last* в качестве последнего. Поскольку в этом enum не будут заданы числовые значения для элементов, можно полагаться на то, что они будут пронумерованы подряд от 0 до N-1, а выражение static*cast<uint32_t>(SomeCityAirport::Last*) будет содержать количество аэропортов (N).
- Класс должен уметь конструироваться по списку аэропортов вылета, а также позволять обновлять этот список: добавить вылет из какого-то аэропорта, удалить один вылет (например, ошибочно добавленный) или удалить из истории все вылеты из некоторого аэропорта.

## Тестирование

Прежде чем перейти к более детальному описанию интерфейса класса, опишем процесс тестирования задачи.

Вам будут даны все тесты, на которых будет проверяться шаблонный класс AirportCounter. Ваша задача — добиться не только корректной работы на этих тестах, но и уложиться на них в 2 секунды. (Считайте, что заказчик предоставил вам подробнейшие сценарии использования вашего класса, которые затем были преобразованы в конкретные бенчмарки.)

Таким образом, вы должны выбрать способ реализации класса, ориентируясь лишь на конкретные бенчмарки.

Отметим, что данные бенчмарки составлены на основе реального примера из высоконагруженного сервиса, замедление которого даже на десятки процентов недопустимо. Именно поэтому в этой задаче важно не только спроектировать решение с приемлемой асимптотической сложностью, но и «разогнать» его на конкретных примерах.
Интерфейс класса

```C++
template <typename TAirport>
class AirportCounter {
public:
// конструктор по умолчанию: список элементов пока пуст
AirportCounter();

// конструктор от диапазона элементов типа TAirport
template <typename TIterator>
AirportCounter(TIterator begin, TIterator end);

// получить количество элементов, равных данному
size_t Get(TAirport airport) const;

// добавить данный элемент
void Insert(TAirport airport);

// удалить одно вхождение данного элемента
void EraseOne(TAirport airport);

// удалить все вхождения данного элемента
void EraseAll(TAirport airport);

using Item = pair<TAirport, size_t>;

// получить некоторый объект, по которому можно проитерироваться,
// получив набор объектов типа Item - пар (аэропорт, количество),
// упорядоченных по аэропорту
??? GetItems() const;

private:
// ???
};
```

[Файл с заготовкой решения и тестами](https://stepik.org/media/attachments/lesson/286768/5zBNao5FEeiEShL6YrwsWg_e7740c708e4511e8bccc6fe6f3f3ac49_airport_counter.cpp)

## Подсказки

Если задача вызывает непреодолимые трудности, вы можете воспользоваться подсказками. Они помогут быстрее сдать задачу, но в итоге вы получите меньше пользы от процесса поиска решения.

Не нужно открывать все подсказки сразу. Используйте их последовательно.

- [Подсказка 1](/Week_4/task_4_airportCounter/airport-counter-1.pdf)
- [Подсказка 2](/Week_4/task_4_airportCounter/airport-counter-2.pdf)
